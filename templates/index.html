<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ROS 2 WebSocket with Pan Control</title>
</head>

<body>
  <div id="loading-overlay">
    <div class="spinner"></div>
    <h5 id="loading-text">Processing...</h5>
  </div>
  <ul id="context-menu" class="custom-menu">
    <li id="end">End</li>
    <li id="zoom">Enable Zoom</li>
    <li id="pan">Enable Pan</li>
    <li id="disable">Disable All</li>
  </ul>
  <div
    style="position: absolute; top: 5px; right: 5px; color: #555; background: rgba(255,255,255,0.7); padding: 2px 5px; font-size: 10px; z-index: 9999; pointer-events: none;">
    v1.3.0
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col s2 column-1 button-container">
        <h5>Menu Content</h5>
        <a href="#!" class="btn menu-btn" data-action="navtopose">Nav to pose</a>
        <a href="#!" class="btn menu-btn" data-action="setpose">Set Pose</a>
        <a href="#!" class="btn menu-btn" data-action="addwaypoint">Add Waypoint</a>

        <a href="#!" class="btn menu-btn" data-action="drawpath">Draw Path</a>
        <a href="#!" class="btn menu-btn disabled" data-action="savepath"
          style="background-color: #7cb342 !important;">Save Path</a>
        <a href="#!" class="btn menu-btn" data-action="pathfollow">Path follower</a>
        <a href="#!" class="btn menu-btn" data-action="none">Disable All</a>
      </div>

      <div class="col s6 column-2">
        <p>Map view (Hold Ctrl+Drag to Pan)</p>
        <div id="3d-viewer"></div>
      </div>

      <div class="col s4 column-3">
        <div class="inner-columns">
          <div class="inner-col-left">
            <h6>View Rotation</h6>
            <div class="rotation-controls-vertical">
              <button class="btn-small rotation-btn" id="rotate-ccw" title="Rotate +90°">↺ +90°</button>
              <button class="btn-small rotation-btn" id="rotate-reset" title="Reset rotation">Reset</button>
              <button class="btn-small rotation-btn" id="rotate-cw" title="Rotate -90°">↻ -90°</button>
            </div>
          </div>

          <div class="inner-col-right">
            <h6>Additional</h6>
            <p>Content here.</p>
            <a href="#!" class="btn menu-btn btn-small btn-green toggle-btn" data-action="toggleminimal"
              id="btn-toggleminimal">Upstart</a>
            <div style="margin-top: 10px;"></div>
            <a href="#!" class="btn menu-btn btn-small btn-purple toggle-btn" data-action="toggleslam"
              id="btn-toggleslam">SLAM Nav</a>
            <div style="margin-top: 10px;"></div>
            <a href="#!" class="btn menu-btn btn-small btn-orange" data-action="savemap">Save Map</a>

            <div style="flex: 1; display: flex; flex-direction: column; min-height: 0; margin-bottom: 0;">
              <!-- Map List (Full Width) -->
              <div style="padding: 2px; flex: 1; display: flex; flex-direction: column;">
                <div id="map-list-container"
                  style="flex: 1; overflow-y: auto; margin-top: 5px; background: white; padding: 5px; border-radius: 4px; border: 1px solid #ddd;">
                  <h6
                    style="margin-top: 0; font-size: 11px; font-weight: bold; color: #333; position: sticky; top: 0; background: white;">
                    Maps</h6>
                  <ul id="map-list" style="margin: 0; padding-left: 10px; font-size: 10px;"></ul>
                </div>
              </div>
            </div>

            <div style="flex: 1; display: flex; gap: 4px; min-height: 0; margin-bottom: 0;">
              <!-- Waypoints (Left Half) -->
              <div style="flex: 1; display: flex; flex-direction: column;">
                <div id="waypoint-list-container"
                  style="flex: 1; overflow-y: auto; margin-top: 5px; background: white; padding: 5px; border-radius: 4px; border: 1px solid #ddd;">
                  <h6
                    style="margin-top: 0; font-size: 11px; font-weight: bold; color: #333; position: sticky; top: 0; background: white;">
                    Waypoints</h6>
                  <ul id="waypoint-list" style="margin: 0; padding-left: 10px; font-size: 10px;"></ul>
                </div>
              </div>

              <!-- Paths (Right Half) -->
              <div style="flex: 1; display: flex; flex-direction: column;">
                <div id="path-list-container"
                  style="flex: 1; overflow-y: auto; margin-top: 5px; background: white; padding: 5px; border-radius: 4px; border: 1px solid #ddd;">
                  <h6
                    style="margin-top: 0; font-size: 11px; font-weight: bold; color: #333; position: sticky; top: 0; background: white;">
                    Paths</h6>
                  <ul id="path-list" style="margin: 0; padding-left: 10px; font-size: 10px;"></ul>
                </div>
              </div>
            </div>

            <div style="margin-top: 5px; display: flex; gap: 5px;">
              <a href="#!" class="btn menu-btn btn-small btn-red disabled" data-action="deletemap"
                style="flex: 1; font-size: 10px; padding: 0;">Delete Map</a>
              <a href="#!" class="btn menu-btn btn-small btn-teal disabled" data-action="gotowaypoint"
                style="flex: 1; font-size: 10px; padding: 0;">Go To WP</a>
            </div>

            <div style="margin-top: 5px; display: flex; gap: 5px;">
              <a href="#!" class="btn menu-btn btn-small btn-purple disabled" data-action="runpath"
                style="flex: 1; font-size: 10px; padding: 0;">Run Path</a>
              <a href="#!" class="btn menu-btn btn-small btn-grey" data-action="clearpath"
                style="flex: 1; font-size: 10px; padding: 0;">Clear Path</a>
            </div>

            <div style="margin-top: 10px;"></div>
            <div style="display: flex; flex-direction: column; gap: 5px;">
              <a href="#!" class="btn menu-btn btn-small btn-blue" data-action="editmask" id="btn-editmask">Edit
                Mask</a>
              <a href="#!" class="btn menu-btn btn-small btn-green disabled" data-action="savemask"
                id="btn-savemask">Save Mask</a>
            </div>

            <div style="margin-top: 5px; display: flex; align-items: center; gap: 10px;">
              <label style="display: flex; align-items: center; color: #333; cursor: pointer;">
                <input type="checkbox" id="chk-showmask" checked />
                <span style="font-size: 11px;">Show Mask</span>
              </label>
              <label style="display: flex; align-items: center; color: #333; cursor: pointer;">
                <input type="checkbox" id="chk-usekeepout" />
                <span style="font-size: 11px;">Use Keepout</span>
              </label>
            </div>

            <div id="brush-control" style="margin-top: 5px; display: none;">
              <div style="font-size: 10px; color: #555;">Brush Size: <span id="brush-size-val">5</span></div>
              <input type="range" id="brush-size" min="1" max="20" value="5" style="width: 100%; margin: 0;" />
              <div style="margin-top: 5px;">
                <a href="#!" id="btn-clearmask"
                  style="font-size: 10px; color: #f44336; text-decoration: underline;">Clear Mask</a>
              </div>
            </div>

            <div style="margin-top: 10px;"></div>
            <a href="#!" class="btn menu-btn btn-small btn-teal toggle-btn" data-action="togglenav"
              id="btn-togglenav">Start Nav</a>

            <div id="nav-status-container"
              style="margin-top: 10px; padding: 8px; background: #f5f5f5; border-radius: 4px; border-left: 3px solid #00897b;">
              <div style="font-size: 10px; font-weight: bold; color: #555; margin-bottom: 3px;">Navigation Status:</div>
              <div id="nav-status-text" style="font-size: 11px; color: #333; min-height: 20px; font-family: monospace;">
                Idle</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="{{ url_for('static', filename='js/three.min.js') }}"></script>
  <link href="{{ url_for('static', filename='css/materialize.min.css') }}" rel="stylesheet" />
  <script src="{{ url_for('static', filename='js/materialize.min.js') }}"></script>

  <style>
    .button-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .full-height {
      height: 100vh;
    }

    .container {
      height: 100%;
    }

    .container-fluid {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      margin: 0;
      height: 100%;
    }

    .row {
      height: 100%;
      margin: 0;
    }

    .rotation-controls-vertical {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }

    .inner-columns {
      display: flex;
      gap: 10px;
      height: 100%;
    }

    .inner-col-left {
      flex: 3;
      padding: 5px;
      background-color: #a5d6a7;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .inner-col-right {
      flex: 5;
      padding: 10px;
      background-color: #90caf9;
      display: flex;
      flex-direction: column;
      gap: 5px;
      overflow: hidden;
      /* Hide main scrollbar, let inner lists scroll */
    }

    .inner-col-left h6,
    .inner-col-right h6 {
      margin-top: 0;
      font-size: 14px;
      font-weight: bold;
    }

    .inner-col-right p {
      font-size: 12px;
      margin: 10px 0;
    }

    .rotation-btn {
      background-color: #1976d2 !important;
      color: white;
      width: 45px !important;
      height: 45px !important;
      min-width: unset !important;
      font-size: 9px;
      padding: 0 !important;
      display: flex !important;
      justify-content: center;
      align-items: center;
      border-radius: 4px;
      line-height: 1.1;
      text-align: center;
      margin: 0 auto;
    }

    .rotation-btn:hover {
      background-color: #1565c0 !important;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #e0e0e0;
    }

    /* Disabled button style */
    .btn.disabled {
      pointer-events: none;
      opacity: 0.5;
      background-color: #9e9e9e !important;
      color: #e0e0e0 !important;
    }

    .btn-green {
      background-color: #4caf50 !important;
    }

    .btn-red {
      background-color: #ef5350 !important;
    }

    .btn-purple {
      background-color: #7e57c2 !important;
    }

    .btn-orange {
      background-color: #ff9800 !important;
    }

    .btn-teal {
      background-color: #00897b !important;
    }

    .btn-pink {
      background-color: #d81b60 !important;
    }

    .toggle-btn.active {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.5), 0 0 0 5px currentColor;
      font-weight: bold;
    }

    /* Loading Overlay */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 9999;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
    }

    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 2s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #3d-viewer {
      width: 100%;
      height: 100%;
      background-color: #e0e0e0;
      cursor: default;
    }

    #3d-viewer.panning {
      cursor: grab;
    }

    #3d-viewer.panning:active {
      cursor: grabbing;
    }

    .column-1 {
      background-color: #ffccbc;
      flex: 1;
      min-width: 150px;
    }

    .column-2 {
      background-color: #bbdefb;
      flex: 3;
    }

    .column-3 {
      background-color: #c8e6c9;
      flex: 2;
    }

    .custom-menu {
      position: absolute;
      display: none;
      background-color: #f9f9f9;
      border: 1px solid #ccc;
      padding: 10px;
      box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    .custom-menu li {
      list-style: none;
      padding: 8px 12px;
      cursor: pointer;
    }

    .custom-menu li:hover {
      background-color: #ddd;
    }
  </style>

  <script>
    // Use the current hostname for the WebSocket connection
    const wsHost = window.location.hostname;
    // Default to port 8888 as per ss.py
    const ws = new WebSocket(`ws://${wsHost}:8888`);
    var mapres = 0;

    function initThreeJS() {
      var container = document.getElementById("3d-viewer");
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientWidth,
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(container.clientWidth, container.clientWidth);
      container.appendChild(renderer.domElement);

      const light = new THREE.AmbientLight(0x404040);
      scene.add(light);

      var grid = new THREE.GridHelper(100, 10);
      grid.geometry.rotateX(Math.PI / 2);
      grid.renderOrder = 6;
      scene.add(grid);

      const axesHelper = new THREE.AxesHelper(5);
      axesHelper.renderOrder = 8;
      scene.add(axesHelper);

      const dir = new THREE.Vector3(1, 0, 0);
      dir.normalize();
      const origin = new THREE.Vector3(0, 0, 0);
      const length = 1;
      const hex = 0xffff00;
      const arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
      arrowHelper.renderOrder = 9;
      scene.add(arrowHelper);

      const waypointMarkers = new THREE.Group();
      scene.add(waypointMarkers);

      let mapCanvas, mapTexture, mapMaterial, mapMesh, org_x, org_y, pointCloud, mheight, arrowPose, map_quatanion;
      let mapres = 0.05; // Default map resolution
      let enableNavToPose = false;
      let enableSetPose = false;
      let enableAddWaypoint = false;
      let enableDrawLine = false;
      let enablePathFollow = false;
      let enableEditMask = false;
      let points = [];
      let line, line_cursor;
      let selectedMap = null;
      let selectedWaypoint = null;

      // Mask editing components
      let maskCanvas, maskCtx, maskTexture, maskMesh;
      let brushSize = 5;
      let isDrawingMask = false;

      let isMinimalRunning = false;
      let isSlamRunning = false;
      let isNavRunning = false;

      // Server-side UI State
      let currentServerState = {
        selected_map: null,
        selected_waypoint_name: null,
        selected_path_name: null
      };

      let lastMapListData = [];
      let lastWPListData = [];
      let lastPathListData = [];

      let selectedPath = null;
      let pathVisualization = null;

      const mainCanvas = renderer.domElement;

      function showLoading(text = "Processing...") {
        document.getElementById('loading-text').innerText = text;
        document.getElementById('loading-overlay').style.display = 'flex';
      }

      function hideLoading() {
        document.getElementById('loading-overlay').style.display = 'none';
      }

      // STATE SYNC: Save locally and to Robot
      function saveUIState() {
        const state = {
          selected_map: selectedMap,
          selected_waypoint_name: selectedWaypoint ? selectedWaypoint.name : null,
          selected_path_name: currentServerState.selected_path_name // Ensure this uses the synced state var
        };
        // Save to LocalStorage as a fallback
        localStorage.setItem('ros2_ui_state', JSON.stringify(state));

        // Sync to the Robot (Backend)
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "ui_state",
            data: state
          }));
        }
      }

      function loadUIState() {
        const saved = localStorage.getItem('ros2_ui_state');
        if (saved) return JSON.parse(saved);
        return null;
      }

      function updateButtonStates() {
        const btnToggleMinimal = document.getElementById('btn-toggleminimal');
        const btnToggleSlam = document.getElementById('btn-toggleslam');
        const btnToggleNav = document.getElementById('btn-togglenav');

        // Minimal
        if (isMinimalRunning) {
          btnToggleMinimal.classList.add('active');
          btnToggleMinimal.textContent = 'Stop';
        } else {
          btnToggleMinimal.classList.remove('active');
          btnToggleMinimal.textContent = 'Upstart';
        }

        // SLAM
        if (isSlamRunning) {
          btnToggleSlam.classList.add('active');
          btnToggleSlam.textContent = 'Stop SLAM';
        } else {
          btnToggleSlam.classList.remove('active');
          btnToggleSlam.textContent = 'SLAM Nav';
        }

        // Nav
        if (isNavRunning) {
          btnToggleNav.classList.add('active');
          btnToggleNav.textContent = 'Stop Nav';
        } else {
          btnToggleNav.classList.remove('active');
          btnToggleNav.textContent = 'Start Nav';
        }
      }

      function updateNavStatus(status, color = '#333') {
        const statusText = document.getElementById('nav-status-text');
        if (statusText) {
          statusText.textContent = status;
          statusText.style.color = color;
        }
      }

      // Pan control variables
      let isPanning = false;
      let previousMousePosition = { x: 0, y: 0 };

      // Camera rotation tracking
      let cameraRotationAngle = 0;
      const initialCameraZ = 500;

      function base64ToArrayBuffer(base64) {
        var binaryString = window.atob(base64);
        var len = binaryString.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      }

      function parsePointCloud2(message) {
        var points = [];
        var data = message.data;
        if (typeof data === "string") {
          data = base64ToArrayBuffer(data);
        }
        if (!(data instanceof ArrayBuffer)) {
          console.error("Data is not in a valid ArrayBuffer format");
          return points;
        }
        var pointStep = message.point_step;
        var offsetX = message.fields.find((f) => f.name === "x").offset;
        var offsetY = message.fields.find((f) => f.name === "y").offset;
        var offsetZ = message.fields.find((f) => f.name === "z").offset;
        var view = new DataView(data);
        for (var i = 0; i < data.byteLength; i += pointStep) {
          var x = view.getFloat32(i + offsetX, true);
          var y = view.getFloat32(i + offsetY, true);
          var z = view.getFloat32(i + offsetZ, true);
          if (isFinite(x) && isFinite(y) && isFinite(z)) {
            points.push(new THREE.Vector3(x, y, z));
          }
        }
        return points;
      }

      function renderPointCloud(points) {
        var geometry = new THREE.BufferGeometry();
        var vertices = new Float32Array(points.length * 3);
        for (var i = 0; i < points.length; i++) {
          vertices[i * 3] = points[i].x / mapres;
          vertices[i * 3 + 1] = points[i].y / mapres;
          vertices[i * 3 + 2] = points[i].z;
        }
        geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
        var material = new THREE.PointsMaterial({ color: 0xff0000, side: THREE.DoubleSide, size: 1 });
        if (pointCloud) {
          scene.remove(pointCloud);
        }
        pointCloud = new THREE.Points(geometry, material);
        pointCloud.renderOrder = 4;
        pointCloud.position.set(0, 0, 0);
        scene.add(pointCloud);
      }

      function updateMapList(maps) {
        lastMapListData = maps;
        const list = document.getElementById("map-list");
        const deleteBtn = document.querySelector('[data-action="deletemap"]');

        list.innerHTML = "";
        maps.forEach(mapName => {
          const li = document.createElement("li");
          li.textContent = mapName;
          li.style.cursor = "pointer";
          li.style.padding = "2px 5px";
          li.style.borderRadius = "2px";

          li.onclick = function () {
            // Remove highlight from all
            Array.from(list.children).forEach(child => child.style.backgroundColor = "transparent");
            // Highlight current
            li.style.backgroundColor = "#e0e0e0";
            selectedMap = mapName;

            // Load waypoints and paths for selected map
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "process", name: "load_waypoints", data: mapName }));
            }

            saveUIState();
          };

          // HIGHLIGHT if it matches server state
          if (currentServerState.selected_map === mapName) {
            li.style.backgroundColor = "#e0e0e0";
            selectedMap = mapName;
            const deleteBtn = document.querySelector('[data-action="deletemap"]');
            if (deleteBtn) deleteBtn.classList.remove('disabled');
            // Don't auto-request here to avoid loops
          }

          list.appendChild(li);
        });

        // Clear other lists if map list is updated (implying refetch/change)
        // Actually keep them unless map changes


        // If no map selected, ensure delete button is disabled
        if (!selectedMap && deleteBtn) {
          deleteBtn.classList.add('disabled');
        }
      }

      function updateWaypointList(wpList) {
        lastWPListData = wpList;
        const list = document.getElementById("waypoint-list");
        const goBtn = document.querySelector('[data-action="gotowaypoint"]');
        list.innerHTML = "";
        selectedWaypoint = null;
        if (goBtn) goBtn.classList.add('disabled');

        if (!wpList || wpList.length === 0) {
          const li = document.createElement("li");
          li.textContent = "No waypoints";
          li.style.color = "#999";
          list.appendChild(li);
          updateWaypointMarkers([]); // Clear markers
          return;
        }

        wpList.forEach(wp => {
          const li = document.createElement("li");
          li.style.cursor = "pointer";
          li.style.padding = "2px 5px";
          li.style.borderRadius = "2px";
          li.style.display = "flex";
          li.style.justifyContent = "space-between";
          li.style.alignItems = "center";

          const nameSpan = document.createElement("span");
          nameSpan.textContent = wp.name;
          nameSpan.style.flex = "1";
          li.appendChild(nameSpan);

          const delBtn = document.createElement("span");
          delBtn.innerHTML = "&times;";
          delBtn.style.color = "red";
          delBtn.style.padding = "0 5px";
          delBtn.style.fontWeight = "bold";
          delBtn.style.fontSize = "16px";
          delBtn.title = "Delete Waypoint";

          delBtn.onclick = function (e) {
            e.stopPropagation(); // Prevent li.onclick
            if (confirm(`Delete waypoint "${wp.name}"?`)) {
              deleteWaypoint(wp.name);
            }
          };
          li.appendChild(delBtn);

          li.onclick = function () {
            Array.from(list.children).forEach(child => child.style.backgroundColor = "transparent");
            li.style.backgroundColor = "#e0e0e0";
            selectedWaypoint = wp;
            if (goBtn) goBtn.classList.remove('disabled');
            saveUIState();
          };
          list.appendChild(li);
        });

        // Update markers on map
        updateWaypointMarkers(wpList);

        // HIGHLIGHT if it matches server state
        if (currentServerState.selected_waypoint_name) {
          Array.from(list.children).forEach(li => {
            const span = li.querySelector('span');
            if (span && span.textContent === currentServerState.selected_waypoint_name) {
              li.style.backgroundColor = "#e0e0e0";
              selectedWaypoint = wpList.find(w => w.name === currentServerState.selected_waypoint_name);
              if (goBtn) goBtn.classList.remove('disabled');
            }
          });
        }
      }

      function updateWaypointMarkers(wpList) {
        // Clear existing markers
        while (waypointMarkers.children.length > 0) {
          waypointMarkers.remove(waypointMarkers.children[0]);
        }

        wpList.forEach(wp => {
          const marker = createWaypointMarker(wp.name, wp.position, wp.orientation);
          waypointMarkers.add(marker);
        });
      }

      function createWaypointMarker(name, pos, ori) {
        const group = new THREE.Group();
        const quat = new THREE.Quaternion(ori.x, ori.y, ori.z, ori.w);
        const origin = new THREE.Vector3(pos.x / mapres, pos.y / mapres, pos.z / mapres);

        const color = 0x006400; // Dark Green
        const mat = new THREE.MeshBasicMaterial({ color: color });

        // Short substantial arrow
        const shaftLength = 6;
        const shaftGeom = new THREE.CylinderGeometry(0.4, 0.4, shaftLength, 12);
        shaftGeom.rotateZ(-Math.PI / 2); // Point along +X
        shaftGeom.translate(shaftLength / 2, 0, 0);
        const shaft = new THREE.Mesh(shaftGeom, mat);

        const headLength = 3;
        const headGeom = new THREE.ConeGeometry(1.2, headLength, 12);
        headGeom.rotateZ(-Math.PI / 2); // Point along +X
        headGeom.translate(shaftLength + headLength / 2, 0, 0);
        const head = new THREE.Mesh(headGeom, mat);

        const arrowGroup = new THREE.Group();
        arrowGroup.add(shaft);
        arrowGroup.add(head);
        arrowGroup.quaternion.copy(quat);

        group.add(arrowGroup);
        group.position.copy(origin);

        // Label
        const label = createLabelText(name);
        label.position.set(0, 0, 5); // Raised slightly
        group.add(label);

        return group;
      }

      function updatePathList(pathList) {
        lastPathListData = pathList;
        const list = document.getElementById("path-list");
        const runBtn = document.querySelector('[data-action="runpath"]');
        list.innerHTML = "";
        selectedPath = null;
        if (runBtn) runBtn.classList.add('disabled');

        if (!pathList || pathList.length === 0) {
          const li = document.createElement("li");
          li.textContent = "No paths";
          li.style.color = "#999";
          list.appendChild(li);
          return;
        }

        pathList.forEach(p => {
          const li = document.createElement("li");
          li.style.cursor = "pointer";
          li.style.padding = "2px 5px";
          li.style.borderRadius = "2px";
          li.style.display = "flex";
          li.style.justifyContent = "space-between";
          li.style.alignItems = "center";

          const nameSpan = document.createElement("span");
          nameSpan.textContent = p.name;
          nameSpan.style.flex = "1";
          li.appendChild(nameSpan);

          const delBtn = document.createElement("span");
          delBtn.innerHTML = "&times;";
          delBtn.style.color = "red";
          delBtn.style.padding = "0 5px";
          delBtn.style.fontWeight = "bold";
          delBtn.style.fontSize = "16px";
          delBtn.title = "Delete Path";

          delBtn.onclick = function (e) {
            e.stopPropagation();
            if (confirm(`Delete path "${p.name}"?`)) {
              deletePath(p.name);
            }
          };
          li.appendChild(delBtn);

          li.onclick = function () {
            Array.from(list.children).forEach(child => child.style.backgroundColor = "transparent");
            li.style.backgroundColor = "#e0e0e0";
            selectedPath = p;
            if (runBtn) {
              runBtn.classList.remove('disabled');
              console.log("Enabled Run Path button for:", p.name);
            }
            visualizePath(p);

            // Update server state 
            currentServerState.selected_path_name = p.name;
            saveUIState();
          };
          list.appendChild(li);
        });

        // HIGHLIGHT if matches server state
        if (currentServerState.selected_path_name) {
          let found = false;
          Array.from(list.children).forEach(li => {
            const span = li.querySelector('span');
            if (span && span.textContent === currentServerState.selected_path_name) {
              li.style.backgroundColor = "#e0e0e0";
              const newSelectedPath = pathList.find(p => p.name === currentServerState.selected_path_name);

              if (newSelectedPath) {
                selectedPath = newSelectedPath; // VISUALIZATION: Ensure selectedPath matches
                if (runBtn) runBtn.classList.remove('disabled');

                // Only visualize if not already visualized or if it's a different path
                // (We'll assume simple re-vis is okay, but avoid heavy loop)
                // Actually, updatePathList is called on "path_list" message.
                // If we are just selecting, we don't get a "path_list" message unless we save/delete.
                // The "ui_state" message triggers a reload of last lists? No.
                // "ui_state" just updates currentServerState. We need to re-run highlight logic then.

                // Visualize ONLY if we haven't already for this specific path update interaction
                // Ideally duplicate calls to visualizePath are cheap-ish (remove and add)
                visualizePath(selectedPath);
                found = true;
              }
            }
          });
          if (!found) {
            // If server says we have a path selected, but it's not in the list (e.g. deleted), clear it.
            currentServerState.selected_path_name = null;
            if (runBtn) runBtn.classList.add('disabled');
          }
        }
      }

      function visualizePath(pathData) {
        if (pathVisualization) scene.remove(pathVisualization);

        // pathData.poses is the array of Pose objects
        // stored as { position: {x,y,z}, orientation: {x,y,z,w} }
        const points = [];
        pathData.poses.forEach(pose => {
          // Need to reverse mapres scaling if it was applied during save?
          // Actually wait, createPoseArrayFromPoints in savePath multiplies by mapres.
          // So here we should divide by mapres to get back to grid coordinates for display?
          // VISUALIZATION is in grid coords. POSE is in meter coords.
          // stored poses are in METERS (x * mapres).
          // So to display, we divide by mapres.
          points.push(new THREE.Vector3(
            pose.position.x / mapres,
            pose.position.y / mapres,
            0 // 2D map
          ));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        // Use thick arrows instead of Line
        // const material = new THREE.LineBasicMaterial({ color: 0xFF00FF, linewidth: 3 });
        // pathVisualization = new THREE.Line(geometry, material);

        pathVisualization = new THREE.Group();
        pathVisualization.renderOrder = 20;

        // Helper to create valid thick arrow
        function createThickArrow(start, end, color, width = 1.5, headWidth = 4, headLen = 10) {
          const direction = new THREE.Vector3().subVectors(end, start);
          const length = direction.length();

          if (length < 0.1) return null; // Too short

          // Cap head length to not exceed segment
          const actualHeadLen = Math.min(headLen, length * 0.4);
          const shaftLen = length - actualHeadLen;

          const arrowGroup = new THREE.Group();
          arrowGroup.position.copy(start);
          arrowGroup.lookAt(end);

          // Shaft (Cylinder)
          // Cylinder alignment is Y-up. But we want Z-forward for lookAt? 
          // Actually lookAt aligns +Z to target.
          // If we build along Z:

          const shaftGeo = new THREE.CylinderGeometry(width, width, shaftLen, 8);
          shaftGeo.rotateX(Math.PI / 2); // Align to Z
          shaftGeo.translate(0, 0, shaftLen / 2); // Move origin to start
          const shaftMat = new THREE.MeshBasicMaterial({ color: color });
          const shaft = new THREE.Mesh(shaftGeo, shaftMat);
          arrowGroup.add(shaft);

          // Head (Cone)
          const headGeo = new THREE.ConeGeometry(headWidth, actualHeadLen, 8);
          headGeo.rotateX(Math.PI / 2);
          headGeo.translate(0, 0, shaftLen + actualHeadLen / 2);
          const headMat = new THREE.MeshBasicMaterial({ color: color });
          const head = new THREE.Mesh(headGeo, headMat);
          arrowGroup.add(head);

          return arrowGroup;
        }

        // 1. Draw Segments
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i];
          const p2 = points[i + 1];
          const arrow = createThickArrow(p1, p2, 0xFF00FF, 0.6, 1.8, 6); // Thinner: 0.6 shaft, 1.8 head
          if (arrow) pathVisualization.add(arrow);
        }

        // 2. Draw Last Point Orientation Arrow
        if (pathData.poses.length > 0) {
          const lastPose = pathData.poses[pathData.poses.length - 1];
          const lastPt = points[points.length - 1];

          // Convert orientation to vector (assuming 2D plane)
          // Orientation is quaternion {x,y,z,w}
          const q = new THREE.Quaternion(
            lastPose.orientation.x,
            lastPose.orientation.y,
            lastPose.orientation.z,
            lastPose.orientation.w
          );

          const v = new THREE.Vector3(1, 0, 0); // Default forward X
          v.applyQuaternion(q);
          v.normalize();

          // Scale vector for display length (e.g. 20 pixels/units)
          const arrowLen = 15;
          const endPt = new THREE.Vector3(
            lastPt.x + v.x * arrowLen,
            lastPt.y + v.y * arrowLen,
            0
          );

          const lastArrow = createThickArrow(lastPt, endPt, 0xFF00FF, 1.0, 3.0, 8); // Slightly thinner
          if (lastArrow) pathVisualization.add(lastArrow);
        }

        scene.add(pathVisualization);
      }

      function clearPathVisualization() {
        if (pathVisualization) scene.remove(pathVisualization);
        pathVisualization = null;
        selectedPath = null;
        const list = document.getElementById("path-list");
        Array.from(list.children).forEach(child => child.style.backgroundColor = "transparent");
        const runBtn = document.querySelector('[data-action="runpath"]');
        if (runBtn) runBtn.classList.add('disabled');
        // Clear server state for path
        currentServerState.selected_path_name = null;
        saveUIState();
      }

      function createLabelText(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const fontSize = 32;
        context.font = 'bold ' + fontSize + 'px Arial';
        const textWidth = context.measureText(text).width;

        const padding = 10;
        canvas.width = textWidth + padding * 2;
        canvas.height = fontSize + padding * 2;

        // Background
        context.fillStyle = 'rgba(0, 100, 0, 0.85)'; // Dark green
        context.fillRect(0, 0, canvas.width, canvas.height);

        // Border
        context.strokeStyle = 'white';
        context.lineWidth = 2;
        context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);

        // Text
        context.fillStyle = 'white';
        context.font = 'bold ' + fontSize + 'px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);

        const aspect = canvas.width / canvas.height;
        const baseSize = 4;
        sprite.scale.set(baseSize * aspect, baseSize, 1);

        return sprite;
      }

      function drawMap(message) {
        const width = message.info.width;
        const height = message.info.height;
        const resolution = message.info.resolution;
        const origin = message.info.origin;
        org_x = origin.position.x;
        org_y = origin.position.y;
        mheight = height;
        mapres = resolution;
        map_quatanion = message.info.origin.orientation;

        const colors = ["#ffffff", "#000000", "#606060"];
        mapCanvas = document.createElement("canvas");
        mapCanvas.width = width;
        mapCanvas.height = height;
        const ctx = mapCanvas.getContext("2d");

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const index = y * width + x;
            const flippedY = height - 1 - y;
            if (message.data[index] == -1) {
              ctx.fillStyle = colors[2];
            } else if (message.data[index] == 0) {
              ctx.fillStyle = colors[0];
            } else {
              ctx.fillStyle = colors[1];
            }
            const worldX = x;
            const worldY = flippedY;
            const canvasX = worldX;
            const canvasY = worldY;
            ctx.fillRect(canvasX, canvasY, 1, 1);
          }
        }

        if (mapTexture) {
          scene.remove(mapMesh);
        }

        mapTexture = new THREE.CanvasTexture(mapCanvas);
        mapTexture.needsUpdate = true;
        mapMaterial = new THREE.MeshBasicMaterial({ map: mapTexture, side: THREE.DoubleSide });
        const mapGeometry = new THREE.PlaneGeometry(width, height);
        mapMesh = new THREE.Mesh(mapGeometry, mapMaterial);
        mapMesh.renderOrder = 1;
        mapMesh.position.set(origin.position.x / resolution + width / 2, origin.position.y / resolution + height / 2, 0);
        scene.add(mapMesh);

        // Initialize Mask Canvas
        initMask(width, height, origin, resolution);
      }

      function initMask(width, height, origin, resolution) {
        if (maskMesh) scene.remove(maskMesh);

        maskCanvas = document.createElement("canvas");
        maskCanvas.width = width;
        maskCanvas.height = height;
        maskCtx = maskCanvas.getContext("2d");

        // Fill with transparent white (255, 255, 255, 0)
        maskCtx.fillStyle = "rgba(255, 255, 255, 0)";
        maskCtx.fillRect(0, 0, width, height);

        maskTexture = new THREE.CanvasTexture(maskCanvas);
        maskTexture.needsUpdate = true;
        const maskMaterial = new THREE.MeshBasicMaterial({
          map: maskTexture,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide
        });
        const maskGeometry = new THREE.PlaneGeometry(width, height);
        maskMesh = new THREE.Mesh(maskGeometry, maskMaterial);
        maskMesh.renderOrder = 2; // Above map
        maskMesh.position.set(origin.position.x / resolution + width / 2, origin.position.y / resolution + height / 2, 0.01);
        scene.add(maskMesh);

        // Initial visibility
        maskMesh.visible = document.getElementById('chk-showmask').checked;
      }

      const geometry_robot = new THREE.ConeGeometry(2, 6, 32);
      geometry_robot.rotateZ(-Math.PI / 2); // Point towards +X
      const material_robot = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const robot_mesh = new THREE.Mesh(geometry_robot, material_robot);
      scene.add(robot_mesh);

      function updatePose(pose) {
        const { x, y, z } = pose.pose.position;
        const { x: qx, y: qy, z: qz, w: qw } = pose.pose.orientation;
        robot_mesh.position.set(x / mapres, y / mapres, z / mapres);
        const euler = new THREE.Euler().setFromQuaternion(new THREE.Quaternion(qx, qy, qz, qw));
        robot_mesh.rotation.set(euler.x, euler.y, euler.z);
      }

      function drawMaskAtMouse(event) {
        if (!maskCtx || !mapMesh || !enableEditMask) return;
        const intersect = getMousePosition(event);
        if (intersect) {
          // Convert World (meters) -> Map (pixels)
          // pixel_x = (world_x - origin_x) / resolution
          // pixel_y = (world_y - origin_y) / resolution

          const pixelX = Math.floor((intersect.x - org_x) / mapres);
          const pixelY = Math.floor((intersect.y - org_y) / mapres);

          // Check bounds
          if (pixelX >= 0 && pixelX < maskCanvas.width && pixelY >= 0 && pixelY < maskCanvas.height) {

            // Draw on mask canvas
            // We use globalCompositeOperation to handle erasing if needed, or just color
            maskCtx.globalCompositeOperation = "source-over";
            maskCtx.fillStyle = "rgba(255, 0, 0, 1)"; // Red

            // Draw circle
            maskCtx.beginPath();
            // Y is flipped in Canvas vs ROS Map usually? 
            // ROS Map: (0,0) is bottom-left. Canvas: (0,0) is top-left.
            // map-server/image_loader: image (0,0) is top-left.
            // In drawMap, we did: const flippedY = height - 1 - y;
            // So pixelY from formula is 'bottom-up'. Canvas needs 'top-down'.
            const canvasY = maskCanvas.height - 1 - pixelY;

            maskCtx.arc(pixelX, canvasY, brushSize, 0, Math.PI * 2);
            maskCtx.fill();

            maskTexture.needsUpdate = true;
          }
        }
      }

      ws.onopen = function () {
        console.log("WebSocket connection opened");
      };

      ws.onmessage = function (event) {
        const message = JSON.parse(event.data);
        if (message.type === "map_list") {
          updateMapList(message.data);
          hideLoading();
        }

        if (message.type === "path_list") {
          updatePathList(message.data);
        }

        if (message.type === "ui_state") {
          const oldMap = currentServerState.selected_map;
          currentServerState = message.data;

          // If map changed from server, refresh list and load waypoints
          if (currentServerState.selected_map && currentServerState.selected_map !== oldMap) {
            // Request waypoints for the newly synced map
            ws.send(JSON.stringify({ type: "process", name: "load_waypoints", data: currentServerState.selected_map }));
          }

          // Re-render lists to show highlights (they use currentServerState internally)
          if (lastMapListData.length > 0) updateMapList(lastMapListData);
          if (lastWPListData.length > 0) updateWaypointList(lastWPListData);
          if (lastPathListData.length > 0) updatePathList(lastPathListData);
        }

        if (message.type === "process_status") {
          // Update state
          const status = message.status === "running";
          if (message.name === "minimal") isMinimalRunning = status;
          if (message.name === "slam_nav") isSlamRunning = status;
          if (message.name === "nav_stack") isNavRunning = status;

          hideLoading();
          updateButtonStates();

          // Update nav status when nav_stack changes
          if (message.name === "nav_stack") {
            if (status) {
              updateNavStatus("Navigation started", "#00897b");
            } else {
              updateNavStatus("Idle", "#666");
            }
          }

          // Optional: Clear selection if Nav stopped
          if (message.name === "nav_stack" && !status) {
            // Maybe keep selection? User choice.
          }
        }
        if (message.type === "nav_feedback") {
          // Display navigation feedback
          const feedback = message.data || {};
          let statusMsg = "Navigating...";

          if (feedback.distance_remaining !== undefined) {
            statusMsg = `Distance: ${feedback.distance_remaining.toFixed(2)}m`;
          } else if (feedback.current_pose) {
            statusMsg = `Position: (${feedback.current_pose.pose.position.x.toFixed(1)}, ${feedback.current_pose.pose.position.y.toFixed(1)})`;
          } else if (feedback.navigation_time) {
            const time = feedback.navigation_time.sec || 0;
            statusMsg = `Time: ${time}s`;
          }

          updateNavStatus(statusMsg, "#00897b");
        }
        if (message.type === "nav_result") {
          // Display navigation result
          if (message.success) {
            updateNavStatus("Goal reached!", "#4caf50");
          } else {
            updateNavStatus(`Failed: ${message.error || "Unknown error"}`, "#ef5350");
          }
        }
        if (message.type === "waypoint_list") {
          updateWaypointList(message.data);
        }
        if (message.topic === "map") {
          drawMap(message.data);
        }
        if (message.topic === "robot_pose_in_map") {
          updatePose(message.data);
        }
        if (message.topic === "scan_pointcloud") {
          var points = parsePointCloud2(message.data);
          renderPointCloud(points);
        }
      };

      ws.onclose = function () {
        console.log("WebSocket connection closed");
      };

      function computeQuaternionFrom2Points(pStart, pEnd) {
        const dx = pEnd.x - pStart.x;
        const dy = pEnd.y - pStart.y;
        const yaw = Math.atan2(dy, dx);
        const q = new THREE.Quaternion();
        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), yaw);
        return q;
      }

      function getPoseFromArrow(arrow) {
        const pose = {
          position: { x: arrow.position.x, y: arrow.position.y, z: arrow.position.z },
          orientation: { x: arrow.quaternion.x, y: arrow.quaternion.y, z: arrow.quaternion.z, w: arrow.quaternion.w }
        };
        return pose;
      }

      function createPoseArrayFromPoints(in_points) {
        if (!in_points || in_points.length === 0) return [];

        // Deduplicate consecutive points to prevent zero-length segments
        const filteredPoints = [];
        for (let i = 0; i < in_points.length; i++) {
          if (i === 0 || in_points[i].distanceTo(in_points[i - 1]) > 0.001) {
            filteredPoints.push(in_points[i]);
          }
        }

        if (filteredPoints.length < 2) {
          const p = filteredPoints[0] || in_points[0];
          return [{
            position: { x: p.x * mapres, y: p.y * mapres, z: p.z * mapres || 0 },
            orientation: { x: 0, y: 0, z: 0, w: 1 }
          }];
        }

        var poses = [];
        for (let i = 0; i < filteredPoints.length; i++) {
          const point = filteredPoints[i];
          let q = new THREE.Quaternion();

          if (i < filteredPoints.length - 1) {
            // Orientation towards next point
            q = computeQuaternionFrom2Points(filteredPoints[i], filteredPoints[i + 1]);
          } else if (i > 0) {
            // Last point: Same as previous segment
            q = computeQuaternionFrom2Points(filteredPoints[i - 1], filteredPoints[i]);
          }

          poses.push({
            position: { x: point.x * mapres, y: point.y * mapres, z: point.z * mapres || 0 },
            orientation: { x: q.x, y: q.y, z: q.z, w: q.w }
          });
        }
        return poses;
      }

      function getMousePosition(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(planeZ, intersectPoint);
        return intersectPoint;
      }

      function createThickerArrow(start, end) {
        const direction = new THREE.Vector3().subVectors(end, start).normalize();
        const length = start.distanceTo(end);
        const shaftGeometry = new THREE.CylinderGeometry(0.3, 0.3, length - 0.3, 32);
        const shaftMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
        shaft.position.copy(start).add(end).multiplyScalar(0.5);
        shaft.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
        const headGeometry = new THREE.ConeGeometry(0.5, 1.0, 32);
        const headMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.copy(end);
        head.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
        const arrow = new THREE.Group();
        arrow.add(shaft);
        arrow.add(head);
        return arrow;
      }

      function createPolyline(pps) {
        const geometry = new THREE.BufferGeometry().setFromPoints(pps);
        const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
        const pline = new THREE.Line(geometry, material);
        pline.renderOrder = 10;
        return pline;
      }

      function pathfollowNav(pathtofollow) {
        const payload = { type: "action", name: "pathfollow", data: pathtofollow };
        ws.send(JSON.stringify(payload));
      }

      function startMinimal() {
        if (ws.readyState === WebSocket.OPEN) {
          const payload = { type: "process", name: "upstart" };
          ws.send(JSON.stringify(payload));
          M.toast({ html: 'Start command sent!', classes: 'green' });

          isMinimalRunning = true;
          updateButtonStates();
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      function stopMinimal() {
        if (ws.readyState === WebSocket.OPEN) {
          const payload = { type: "process", name: "stop_upstart" };
          ws.send(JSON.stringify(payload));
          M.toast({ html: 'Stop command sent!', classes: 'orange' });

          isMinimalRunning = false;
          updateButtonStates();
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      function toggleMinimal() {
        if (isMinimalRunning) {
          stopMinimal();
        } else {
          startMinimal();
        }
      }

      function startSlam() {
        if (ws.readyState === WebSocket.OPEN) {
          const payload = { type: "process", name: "start_slam" };
          ws.send(JSON.stringify(payload));
          M.toast({ html: 'SLAM Start command sent!', classes: 'green' });

          isSlamRunning = true;
          updateButtonStates();
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      function stopSlam() {
        if (ws.readyState === WebSocket.OPEN) {
          const payload = { type: "process", name: "stop_slam" };
          ws.send(JSON.stringify(payload));
          M.toast({ html: 'SLAM Stop command sent!', classes: 'orange' });

          isSlamRunning = false;
          updateButtonStates();
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      function toggleSlam() {
        if (isSlamRunning) {
          stopSlam();
        } else {
          startSlam();
        }
      }

      function saveMap() {
        if (ws.readyState === WebSocket.OPEN) {
          const mapName = prompt("Enter map name to save:", "my_new_map");
          if (mapName) {
            const payload = { type: "process", name: "save_map", data: mapName };
            ws.send(JSON.stringify(payload));
            M.toast({ html: `Saving map as ${mapName}...`, classes: 'blue' });
          }
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      function startNav() {
        if (ws.readyState === WebSocket.OPEN) {
          if (!selectedMap) {
            alert("Please select a map from the list first!");
            return;
          }
          const useKeepout = document.getElementById('chk-usekeepout').checked;
          const payload = {
            type: "process",
            name: "start_nav",
            data: selectedMap,
            use_keepout: useKeepout
          };
          ws.send(JSON.stringify(payload));
          M.toast({ html: `Starting navigation with map: ${selectedMap} (Keepout: ${useKeepout})`, classes: 'green' });

          isNavRunning = true;
          updateButtonStates();
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      function stopNav() {
        if (ws.readyState === WebSocket.OPEN) {
          const payload = { type: "process", name: "stop_nav" };
          ws.send(JSON.stringify(payload));
          M.toast({ html: 'Stopping navigation...', classes: 'orange' });

          isNavRunning = false;
          updateButtonStates();
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      document.getElementById('chk-showmask').addEventListener('change', function () {
        if (maskMesh) maskMesh.visible = this.checked;
      });

      document.getElementById('brush-size').addEventListener('input', function () {
        brushSize = parseInt(this.value);
        document.getElementById('brush-size-val').innerText = brushSize;
      });

      document.getElementById('btn-clearmask').addEventListener('click', function (e) {
        e.preventDefault();
        if (confirm("Clear current mask drawing?")) {
          if (maskCtx && maskCanvas) {
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            maskCtx.fillStyle = "rgba(255, 255, 255, 0)";
            maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
            maskTexture.needsUpdate = true;
          }
        }
      });

      function toggleNav() {
        if (isNavRunning) {
          stopNav();
        } else {
          startNav();
        }
      }

      function saveMask() {
        if (!selectedMap || !maskCanvas || !mapCanvas) return;

        // Create a composite canvas to merge the original map and the mask
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = maskCanvas.width;
        tempCanvas.height = maskCanvas.height;
        const tempCtx = tempCanvas.getContext("2d");

        // 1. Draw the original map layout
        tempCtx.drawImage(mapCanvas, 0, 0);

        // 2. Draw the red mask strokes on top
        tempCtx.drawImage(maskCanvas, 0, 0);

        const maskData = tempCanvas.toDataURL("image/png");

        if (ws.readyState === WebSocket.OPEN) {
          const payload = {
            type: "process",
            name: "save_mask",
            map_name: selectedMap,
            mask_data: maskData
          };
          ws.send(JSON.stringify(payload));
          M.toast({ html: 'Saving mask with context...', classes: 'blue' });
        }
      }

      function deleteWaypoint(wpName) {
        if (ws.readyState === WebSocket.OPEN) {
          if (!selectedMap) return;
          const payload = {
            type: "process",
            name: "delete_waypoint",
            data: { map_name: selectedMap, waypoint_name: wpName }
          };
          ws.send(JSON.stringify(payload));
          M.toast({ html: `Deleting waypoint ${wpName}...`, classes: 'red' });
        }
      }

      function savePath() {
        if (ws.readyState === WebSocket.OPEN) {
          if (!selectedMap) {
            alert("Please select a map first!");
            return;
          }
          // Points are in points array. 
          // We need to store them as Pose objects (like createPoseArrayFromPoints does)
          // BUT persisted.
          // createPoseArrayFromPoints returns an array of {position, orientation} objects (conceptually)
          // Let's re-use that logic but structure it for saving.

          if (points.length < 2) {
            alert("Please draw a path with at least 2 points first.");
            return;
          }

          const pathName = prompt("Enter a name for this path:", "Path_1");
          if (!pathName) return;

          const poses = createPoseArrayFromPoints(points);

          const payload = {
            type: "process",
            name: "save_path",
            data: {
              map_name: selectedMap,
              path: {
                name: pathName,
                poses: poses
              }
            }
          };
          ws.send(JSON.stringify(payload));
          M.toast({ html: `Saving path ${pathName}...`, classes: 'green' });

          // Clear drawing
          if (line_cursor) scene.remove(line_cursor);
          points = [];
          enableDrawLine = false;
          document.querySelector('[data-action="savepath"]').classList.add('disabled');
        }
      }

      function deletePath(pathName) {
        if (ws.readyState === WebSocket.OPEN) {
          if (!selectedMap) return;
          const payload = {
            type: "process",
            name: "delete_path",
            data: { map_name: selectedMap, path_name: pathName }
          };
          ws.send(JSON.stringify(payload));
          M.toast({ html: `Deleting path ${pathName}...`, classes: 'red' });
        }
      }


      function deleteMap() {
        if (ws.readyState === WebSocket.OPEN) {
          if (!selectedMap) {
            alert("Please select a map to delete first!");
            return;
          }

          if (confirm(`Are you sure you want to delete the map "${selectedMap}"? This cannot be undone.`)) {
            const payload = { type: "process", name: "delete_map", data: selectedMap };
            ws.send(JSON.stringify(payload));
            M.toast({ html: `Deleting map: ${selectedMap}`, classes: 'red' });

            // Clear selection
            selectedMap = null;
            const deleteBtn = document.querySelector('[data-action="deletemap"]');
            if (deleteBtn) {
              deleteBtn.classList.add('disabled');
            }
          }
        } else {
          console.error("WebSocket is not connected. State:", ws.readyState);
          alert("WebSocket is not connected. Please ensure ss.py is running and refresh the page.");
        }
      }

      // Camera rotation functions
      function rotateCamera(degrees) {
        cameraRotationAngle += degrees;
        const radians = cameraRotationAngle * Math.PI / 180;
        camera.rotation.z = radians;
      }

      function resetCamera() {
        cameraRotationAngle = 0;
        // Keep current zoom (Z position) and pan (X, Y position)
        const currentX = camera.position.x;
        const currentY = camera.position.y;
        const currentZ = camera.position.z;

        // Reset all rotation components
        camera.rotation.set(0, 0, 0);
        camera.position.set(currentX, currentY, currentZ);
        camera.up.set(0, 1, 0);
      }

      // Rotation button events
      document.getElementById("rotate-cw").addEventListener("click", () => {
        rotateCamera(-90);
      });

      document.getElementById("rotate-ccw").addEventListener("click", () => {
        rotateCamera(90);
      });

      document.getElementById("rotate-reset").addEventListener("click", () => {
        resetCamera();
      });

      // Mouse event handlers
      let startPoint = null;
      let arrowGroup = null;

      mainCanvas.addEventListener("mousedown", (event) => {
        // Pan mode: Ctrl + Left Click
        if (event.ctrlKey && event.button === 0) {
          isPanning = true;
          previousMousePosition = { x: event.clientX, y: event.clientY };
          container.classList.add('panning');
          event.preventDefault();
          return;
        }

        // Existing functionality
        if (enableNavToPose || enableSetPose || enableAddWaypoint) {
          startPoint = getMousePosition(event);
        }
        if (enableEditMask) {
          isDrawingMask = true;
          drawMaskAtMouse(event);
          return;
        }

        if (enableDrawLine) {
          // ONLY add points on left click (button 0)
          // Right click is reserved for context menu "End"
          if (event.button === 0) {
            const intersects = getMousePosition(event);
            const point = intersects;
            points.push(new THREE.Vector3(point.x, point.y, point.z));
            if (line) {
              scene.remove(line);
            }
            line = createPolyline(points);
            scene.add(line);
          }
        }
      });

      mainCanvas.addEventListener("mousemove", (event) => {
        // Handle panning
        // Handle panning
        if (isPanning) {
          const deltaX = event.clientX - previousMousePosition.x;
          const deltaY = event.clientY - previousMousePosition.y;

          // Calculate pan amount based on camera distance
          const panSpeed = 0.5;

          // Account for camera rotation when panning
          const rotationRad = camera.rotation.z;
          const cosRot = Math.cos(rotationRad);
          const sinRot = Math.sin(rotationRad);

          // Screen Movement to World Movement Conversion
          // Screen X+ is Right. Screen Y+ is Down.
          // World X+ is Right. World Y+ is Up.
          const screenDX = deltaX;
          const screenDY = -deltaY; // Invert Y because screen Y is down, world Y is up

          // Rotate vector to align with world axes
          const worldDX = screenDX * cosRot - screenDY * sinRot;
          const worldDY = screenDX * sinRot + screenDY * cosRot;

          // Move camera opposite to drag to pan the view
          camera.position.x -= worldDX * panSpeed;
          camera.position.y -= worldDY * panSpeed;

          previousMousePosition = { x: event.clientX, y: event.clientY };
          event.preventDefault();
          return;
        }

        // Existing functionality
        if (enableNavToPose || enableSetPose || enableAddWaypoint) {
          if (startPoint) {
            const endPoint = getMousePosition(event);
            if (endPoint) {
              if (arrowGroup) {
                scene.remove(arrowGroup);
              }
              arrowGroup = createThickerArrow(startPoint, endPoint);
              const resultQuaternion = computeQuaternionFrom2Points(startPoint, endPoint);
              arrowPose = {
                position: { x: startPoint.x * mapres, y: startPoint.y * mapres, z: startPoint.z * mapres },
                orientation: { x: resultQuaternion.x, y: resultQuaternion.y, z: resultQuaternion.z, w: resultQuaternion.w }
              };
              scene.add(arrowGroup);
            }
          }
        }
        if (enableDrawLine) {
          if (points.length > 0) {
            const intersects = getMousePosition(event);
            const p1 = new THREE.Vector3(points[points.length - 1].x, points[points.length - 1].y, points[points.length - 1].z);
            const p2 = new THREE.Vector3(intersects.x, intersects.y, intersects.z);
            const line_cursor_p = [p1, p2];
            if (line_cursor) {
              scene.remove(line_cursor);
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(line_cursor_p);
            const material = new THREE.LineBasicMaterial({ color: 0x3300ff });
            line_cursor = new THREE.Line(geometry, material);
            line_cursor.renderOrder = 11;
            scene.add(line_cursor);
          }
        }
        if (enableEditMask && isDrawingMask && maskCtx) {
          drawMaskAtMouse(event);
        }
      });

      mainCanvas.addEventListener("mouseup", (event) => {
        // Stop drawing mask
        if (isDrawingMask) {
          isDrawingMask = false;
          return;
        }

        // Stop panning
        if (isPanning) {
          isPanning = false;
          container.classList.remove('panning');
          return;
        }

        // Existing functionality
        startPoint = null;
        if (enableNavToPose) {
          if (arrowGroup) {
            const payload = { type: "action", name: "navtopose", data: arrowPose };
            ws.send(JSON.stringify(payload));
            enableNavToPose = false;
          }
        }
        if (enableSetPose) {
          if (arrowGroup) {
            const payload = { type: "action", name: "set_pose", data: arrowPose };
            ws.send(JSON.stringify(payload));
            enableSetPose = false;
          }
        }
        if (enableAddWaypoint) {
          if (arrowGroup) {
            const wpName = prompt("Enter Waypoint Name:");
            if (wpName) {
              const payload = {
                type: "process",
                name: "save_waypoint",
                data: {
                  map_name: selectedMap,
                  waypoint: {
                    name: wpName,
                    position: arrowPose.position,
                    orientation: arrowPose.orientation
                  }
                }
              };
              ws.send(JSON.stringify(payload));
              M.toast({ html: `Saving waypoint ${wpName}...`, classes: 'rounded' });
              enableAddWaypoint = false;
            }
          }
        }
        if (enableDrawLine) {
          if (line_cursor) {
            scene.remove(line_cursor);
          }
        }
      });

      // Zoom with mouse wheel
      mainCanvas.addEventListener("wheel", (event) => {
        event.preventDefault();
        const zoomSpeed = 10;
        camera.position.z += event.deltaY * zoomSpeed * 0.01;
        camera.position.z = Math.max(50, Math.min(1000, camera.position.z));
      });

      const contextMenu = document.getElementById("context-menu");
      renderer.domElement.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        if (isPanning || event.ctrlKey) {
          return;
        }
        contextMenu.style.display = "block";
        contextMenu.style.left = `${event.clientX}px`;
        contextMenu.style.top = `${event.clientY}px`;
      });

      function hideContextMenu() {
        contextMenu.style.display = "none";
      }

      document.addEventListener("click", () => {
        hideContextMenu();
      });

      document.getElementById("end").addEventListener("click", () => {
        if (enableDrawLine) {
          enableDrawLine = false;
          // Finish current line visual if any special handling needed, 
          // but points are already pushed.
          if (line_cursor) {
            scene.remove(line_cursor);
          }
          // Enable Save Path button
          document.querySelector('[data-action="savepath"]').classList.remove('disabled');
          M.toast({ html: 'Path drawing finished. Click "Save Path" to save.', classes: 'green' });

          // Do NOT clear points yet, user needs to save them.
        }
        hideContextMenu();
      });

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();

      camera.position.set(0, 0, 500);

      window.addEventListener("resize", () => {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
      });

      document.addEventListener("keydown", function (event) {
        if (event.key === "Escape" || event.keyCode === 27) {
          if (enableDrawLine) {
            if (line_cursor) {
              scene.remove(line_cursor);
            }
            enableDrawLine = false;
          }
        }
      });

      document.querySelectorAll(".menu-btn").forEach((button) => {
        button.addEventListener("click", function () {
          const action = this.getAttribute("data-action");
          switch (action) {
            case "navtopose":
              if (line_cursor) scene.remove(line_cursor);
              enableNavToPose = true;
              enableSetPose = false;
              enableDrawLine = false;
              enablePathFollow = false;
              break;
            case "setpose":
              if (line_cursor) scene.remove(line_cursor);
              enableNavToPose = false;
              enableSetPose = true;
              enableDrawLine = false;
              enablePathFollow = false;
              break;
            case "drawpath":
              if (line_cursor) scene.remove(line_cursor);
              if (line) {
                scene.remove(line);
                points.length = 0;
              }
              enableNavToPose = false;
              enableSetPose = false;
              enableDrawLine = true;
              enablePathFollow = false;
              break;
            case "pathfollow":
              if (line_cursor) scene.remove(line_cursor);
              enableNavToPose = false;
              enableSetPose = false;
              enableDrawLine = false;
              enablePathFollow = true;
              // Instead of running immediately, we just finish drawing
              // Use "Save Path" or "Path Follower" logic?
              // The user said "Path Follower" button executes drawn path. 
              // BUT now they want to SAVE it.
              // Let's keep existing "pathfollow" behavior as "Run Drawn Path Immediately"
              // AND enable the key "Save Path" button.
              const poses = createPoseArrayFromPoints(points);
              pathfollowNav(poses);
              // Enable Save button now that we have points
              document.querySelector('[data-action="savepath"]').classList.remove('disabled');
              break;
            case "savepath":
              savePath();
              break;
            case "runpath":
              if (selectedPath) {
                pathfollowNav(selectedPath.poses);
              }
              break;
            case "clearpath":
              clearPathVisualization();
              break;
            case "toggleminimal":
              toggleMinimal();
              break;
            case "toggleslam":
              toggleSlam();
              break;
            case "savemap":
              saveMap();
              break;
            case "togglenav":
              toggleNav();
              break;
            case "deletemap":
              deleteMap();
              break;
            case "addwaypoint":
              if (!selectedMap) {
                alert("Please select a map first!");
                return;
              }
              if (line_cursor) scene.remove(line_cursor);
              enableNavToPose = false;
              enableSetPose = false;
              enableAddWaypoint = true;
              enableDrawLine = false;
              enablePathFollow = false;
              M.toast({ html: 'Click and drag on map to set waypoint', classes: 'rounded' });
              break;
            case "gotowaypoint":
              if (selectedWaypoint) {
                const payload = { type: "action", name: "navtopose", data: selectedWaypoint };
                ws.send(JSON.stringify(payload));
                M.toast({ html: `Navigating to ${selectedWaypoint.name}...`, classes: 'blue' });
              }
              break;
            case "editmask":
              enableEditMask = !enableEditMask;
              this.classList.toggle('active', enableEditMask);
              document.getElementById('btn-savemask').classList.toggle('disabled', !enableEditMask);
              document.getElementById('brush-control').style.display = enableEditMask ? 'block' : 'none';
              if (enableEditMask) {
                M.toast({ html: 'Drawing mode enabled. Click and drag to mark keepout zones.', classes: 'blue' });
                if (maskMesh) maskMesh.visible = true;
                document.getElementById('chk-showmask').checked = true;
              }
              break;
            case "savemask":
              saveMask();
              break;
            case "none":
              if (line_cursor) scene.remove(line_cursor);
              enableNavToPose = false;
              enableSetPose = false;
              enableDrawLine = false;
              enablePathFollow = false;
              break;
          }
        });
      });

      // Initialize button states
      updateButtonStates();

    } // End initThreeJS

    document.addEventListener("DOMContentLoaded", initThreeJS);
  </script>
</body>

</html>